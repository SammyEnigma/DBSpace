/*
Deployment script for LCCHPPublic

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "LCCHPPublic"
:setvar DefaultFilePrefix "LCCHPPublic"
:setvar DefaultDataPath "D:\MSSQL\Data\"
:setvar DefaultLogPath "D:\MSSQL\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [dbo].[BloodTestResults].[HistoricLabID] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[BloodTestResults])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [dbo].[DateRanges] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [dbo].[DateRanges])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
Table [dbo].[LabOriginal] is being dropped.  Deployment will halt if the table contains data.
*/

IF EXISTS (select top 1 1 from [dbo].[LabOriginal])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Dropping [dbo].[BloodTestResults].[HistoricLabID].[MS_Description]...';


GO
EXECUTE sp_dropextendedproperty @name = N'MS_Description', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'BloodTestResults', @level2type = N'COLUMN', @level2name = N'HistoricLabID';


GO
PRINT N'Dropping [dbo].[DF_PersonToStatus_StatusDate]...';


GO
ALTER TABLE [dbo].[PersonToStatus] DROP CONSTRAINT [DF_PersonToStatus_StatusDate];


GO
PRINT N'Dropping [dbo].[CK_PositiveRange]...';


GO
ALTER TABLE [dbo].[DateRanges] DROP CONSTRAINT [CK_PositiveRange];


GO
PRINT N'Dropping [dbo].[DateRanges]...';


GO
DROP TABLE [dbo].[DateRanges];


GO
PRINT N'Dropping [dbo].[LabOriginal]...';


GO
DROP TABLE [dbo].[LabOriginal];


GO
PRINT N'Altering [dbo].[BloodTestResults]...';


GO
ALTER TABLE [dbo].[BloodTestResults] DROP COLUMN [HistoricLabID];


GO
ALTER TABLE [dbo].[BloodTestResults]
    ADD [HistoricLabResultsID] VARCHAR (10) NULL;


GO
PRINT N'Altering [dbo].[Family]...';


GO
ALTER TABLE [dbo].[Family] ALTER COLUMN [Pets] TINYINT NULL;


GO
ALTER TABLE [dbo].[Family]
    ADD [FrequentlyWashPets] BIT NULL;


GO
PRINT N'Altering [dbo].[Property]...';


GO
ALTER TABLE [dbo].[Property]
    ADD [Street] VARCHAR (50) NULL;


GO
PRINT N'Creating [dbo].[TravelNotes]...';


GO
CREATE TABLE [dbo].[TravelNotes] (
    [TravelNotesID] INT            IDENTITY (1, 1) NOT NULL,
    [FamilyID]      INT            NOT NULL,
    [CreatedDate]   DATETIME       NULL,
    [Notes]         VARCHAR (3000) NOT NULL,
    [StartDate]     DATE           NULL,
    [EndDate]       DATE           NULL,
    CONSTRAINT [PK_TravelNotes] PRIMARY KEY CLUSTERED ([TravelNotesID] ASC)
);


GO
PRINT N'Creating [dbo].[DF_PersonToStatus_StatusDate]...';


GO
ALTER TABLE [dbo].[PersonToStatus]
    ADD CONSTRAINT [DF_PersonToStatus_StatusDate] DEFAULT (CONVERT([date],getdate())) FOR [StatusDate];


GO
PRINT N'Creating [dbo].[DF_TravelNotes_CreatedDate]...';


GO
ALTER TABLE [dbo].[TravelNotes]
    ADD CONSTRAINT [DF_TravelNotes_CreatedDate] DEFAULT (getdate()) FOR [CreatedDate];


GO
PRINT N'Creating [dbo].[FK_TravelNotes_Family]...';


GO
ALTER TABLE [dbo].[TravelNotes] WITH NOCHECK
    ADD CONSTRAINT [FK_TravelNotes_Family] FOREIGN KEY ([FamilyID]) REFERENCES [dbo].[Family] ([FamilyID]);


GO
PRINT N'Altering [dbo].[trUpdateStatus]...';


GO
ALTER trigger [dbo].[trUpdateStatus] on [dbo].[TargetStatus] AFTER UPDATE
	as
	 begin
	  if @@rowcount = 0
		return
	  if not update(ModifiedDate) update TargetStatus set ModifiedDate = getdate() where StatusID in (select StatusID from inserted)

	end
GO
PRINT N'Creating [dbo].[udf_DoesPropertyExist]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20150322
-- Description:	Function to check for duplicate property
-- =============================================
CREATE FUNCTION udf_DoesPropertyExist 
(
	-- Add the parameters for the function here
	@AddressLine1 varchar(100),
	@City varchar(50),
	@State char(2),
	@ZipCode varchar(12)
)
RETURNS int
AS
BEGIN
	-- Declare the return variable here
	DECLARE @PropertyID int

	-- Add the T-SQL statements to compute the return value here
	SELECT @PropertyID = PropertyID from Property where
		replace(AddressLine1,'.','') = replace(@AddressLine1,'.','') and City = @City 
		and [State] = @State and Zipcode = @ZipCode
	
	-- Return the result of the function
	RETURN @PropertyID

END
GO
PRINT N'Creating [dbo].[vNursingMothers]...';


GO
CREATE View vNursingMothers
AS
	Select P.PersonID, P.LastName,P.FirstName,P.Age
			, Q1.isNursing, Q2.QuestionnaireDate 
			, Q2.QuestionnaireID
	From [questionnaire] As Q1
	Inner Join (
		Select max(QuestionnaireID) AS QuestionnaireID,personID
			  ,max(QuestionnaireDate) as [QuestionnaireDate]
		From [Questionnaire]
		Group By [personID]) As [Q2]
	On Q1.QuestionnaireID = Q2.QuestionnaireID
	INNER JOIN Person AS P on P.PersonID = Q1.PersonID
	where Q1.isNursing = 1
GO
PRINT N'Altering [dbo].[usp_InsertNewBloodLeadTestResultsWebScreen]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20141217
-- Description:	stored procedure to insert data retrieved from 
--				the Blood Lead Test Results web screen
-- =============================================
ALTER PROCEDURE [dbo].[usp_InsertNewBloodLeadTestResultsWebScreen] 
	-- Add the parameters for the stored procedure here
	@Person_ID int = NULL, 
	@Sample_Date date = NULL,
	@Lab_Date date = Null,
	@Blood_Lead_Result numeric(9,4)= NULL, -- Is this Lead value?
	@Flag INT = 365, -- flag follow up date
	@Test_Type tinyint = NULL, -- SampleTypeID need to determine if/how new testTypes are created
	@Lab varchar(50) = NULL,  -- is this necessary i think the lab should be selected from a drop down with the option to add a new lab and an id should be passed?
	@Lab_ID int = NULL,
	@Child_Status_Code smallint = NULL, -- StatusID need to determine if/how new statusCodes are created
	@Child_Status_Date date = NULL,
	@Hemoglobin_Value numeric(9,4) = NULL,
	@DEBUG bit = 0,
	@Blood_Test_Results_ID int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @BloodTestResult_return_value int, @RetestDate_return_value int
			,@Retest_Date date, @ChildStatusCode_return_value int, @ErrorLogID int;

	-- set default date if necessary 
	IF (@Sample_Date is null) 
	BEGIN
		set @Sample_Date = GetDate();
		RAISERROR ('Need to specify the SampleDate, setting to today by default', 5, 0);
	END
	
	IF (@Person_ID IS NULL)
	BEGIN
		RAISERROR ('Client name must be supplied', 11, -1);
		RETURN;
	END;
	BEGIN TRY
		EXEC	@BloodTestResult_return_value = [dbo].[usp_InsertBloodTestResults]
				@isBaseline = NULL,
				@PersonID = @Person_ID,
				@SampleDate = @Sample_Date,
				@LabSubmissionDate = @Lab_Date,
				@LeadValue = @Blood_Lead_Result,
				@LeadValueCategoryID = NULL,
				@HemoglobinValue = @Hemoglobin_Value,
				@HemoglobinValueCategoryID = NULL,
				@HematocritValueCategoryID = NULL,
				@LabID = @Lab_ID,
				@BloodTestCosts = NULL,
				@sampleTypeID = @Test_Type,
				@New_Notes = NULL,
				@TakenAfterPropertyRemediationCompleted = NULL,
				@BloodTestResultID = @Blood_Test_Results_ID OUTPUT

		IF (@Child_Status_Code IS NOT NULL)
		BEGIN
			IF (@Child_Status_Date IS NULL)
				SELECT @Child_Status_Date = GetDate();
			IF @DEBUG = 1
				SELECT '@ChildStatusCode_return_value = [dbo].[usp_InsertPersontoStatus] @PersonID = @Person_ID, @StatusID = @Child_Status_Code, @StatusDate = @Child_Status_Date' 
							,@Person_ID , @Child_Status_Code, @Child_Status_Date

			EXEC	@ChildStatusCode_return_value = [dbo].[usp_InsertPersontoStatus]
					@PersonID = @Person_ID,
					@StatusID = @Child_Status_Code,
					@StatusDate = @Child_Status_Date
		END

		-- set the retest date based on integer value passed in as Flag
		SET @Retest_Date = DATEADD(dd,@Flag,@Sample_Date);

		-- update Person table with the new retest date
		EXEC	@RetestDate_return_value = [dbo].[usp_upPerson]
				@Person_ID = @Person_ID,
				@New_RetestDate = @Retest_Date;
	END TRY
	BEGIN CATCH
	    -- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH; 	
END
GO
PRINT N'Altering [dbo].[usp_upFamily]...';


GO

-- =============================================
-- Author:		William Thier
-- Create date: 20150214
-- Description:	Stored Procedure to update Family information
-- =============================================

ALTER PROCEDURE [dbo].[usp_upFamily]  
	-- Add the parameters for the stored procedure here
	@Family_ID int = NULL,
	@New_Last_Name varchar(50) = NULL,
	@New_Number_of_Smokers tinyint = 0,
	@New_Primary_Language_ID tinyint = 1,
	@New_Notes varchar(3000) = NULL,
	@New_Pets tinyint = NULL,
	@New_Frequently_Wash_Pets bit = NULL,
	@New_in_and_out bit = NULL,
	@New_Primary_Property_ID int = NULL,
	@DEBUG BIT = 0

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	DECLARE @ErrorLogID int, @spupdateFamilysqlStr nvarchar(4000)
			, @NotesID INT, @Recompile BIT = 1;
	
	-- BUILD update statement
	IF (@New_Last_Name IS NULL)
		SELECT @New_Last_Name = LastName from family where FamilyID = @Family_ID;
	
	SELECT @spupdateFamilysqlStr = N'update Family set Lastname = @LastName'

	IF (@New_Number_of_Smokers IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', NumberofSmokers = @NumberofSmokers'

	IF (@New_Primary_Language_ID IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', PrimaryLanguageID = @PrimaryLanguageID'

	IF (@New_Pets IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', Pets = @Pets'

	IF (@New_Pets IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', FrequentlyWashPets = @New_Frequently_Wash_Pets'	
			
	IF (@New_in_and_out IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', inandout = @inandout'

	IF (@New_Primary_Property_ID IS NOT NULL)
		SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N', PrimaryPropertyID = @PrimaryPropertyID'

	SELECT @spupdateFamilysqlStr = @spupdateFamilysqlStr + N' WHERE FamilyID = @FamilyID'

	BEGIN TRY -- update Family information
		IF @DEBUG = 1
			SELECT @spupdateFamilysqlStr, 'Lastname' = @New_Last_Name, 'NumberofSmokers' = @New_Number_of_Smokers
				, 'PrimaryLanguageID' = @New_Primary_Language_ID, 'Notes' = @New_Notes
			IF (@New_Notes IS NOT NULL)
			BEGIN
				EXEC	[dbo].[usp_InsertFamilyNotes]
							@Family_ID = @Family_ID,
							@Notes = @New_Notes,
							@InsertedNotesID = @NotesID OUTPUT
			END
			EXEC [sp_executesql] @spupdateFamilysqlStr
				, N'@LastName VARCHAR(50), @NumberofSmokers tinyint, @PrimaryLanguageID tinyint
				, @Pets BIT, @inandout BIT, @PrimaryPropertyID int, @FamilyID int'
				, @LastName = @New_Last_Name
				, @NumberofSmokers = @New_Number_of_Smokers
				, @PrimaryLanguageID = @New_Primary_Language_ID
				, @Pets = @New_Pets
				, @inandout = @New_in_and_out
				, @PrimaryPropertyID = @New_Primary_Property_ID
				, @FamilyID = @Family_ID
	END TRY -- update Family
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH; 
END
GO
PRINT N'Altering [dbo].[usp_InsertProperty]...';


GO


-- =============================================
-- Author:		William Thier
-- Create date: 20140817
-- Description:	Stored Procedure to insert new property records
-- =============================================

ALTER PROCEDURE [dbo].[usp_InsertProperty]   -- usp_InsertProperty 
	-- Add the parameters for the stored procedure here
	@ConstructionTypeID tinyint = NULL,
	@AreaID int = NULL,
	@isinHistoricDistrict bit = NULL, 
	@isRemodeled bit = NULL,
	@RemodelDate date = NULL,
	@isinCityLimits bit = NULL,
	-- @StreetNumber smallint = NULL,
	@AddressLine1 varchar(100) = NULL,
	-- @StreetSuffix varchar(20) = NULL,
	@Apartmentnumber varchar(10) = NULL,
	@City varchar(50) = NULL,
	@State char(2) = NULL,
	@Zipcode varchar(12) = NULL,
	@YearBuilt date = NULL,
	@Ownerid int = NULL,
	@isOwnerOccuppied bit = NULL,
	@ReplacedPipesFaucets tinyint = 0,
	@TotalRemediationCosts money = NULL,
	@New_PropertyNotes varchar(3000) = NULL,
	@isResidential bit = NULL,
	@isCurrentlyBeingRemodeled bit = NULL,
	@hasPeelingChippingPaint bit = NULL,
	@County varchar(50) = NULL,
	@isRental bit = NULL,
	@OverRideDuplicate bit = 0,
	@PropertyID int OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrorLogID int, @NotesID int;
    -- Insert statements for procedure here


	BEGIN TRY
		SELECT @PropertyID =
				--replace(AddressLine1,'.','') = replace(@AddressLine1,'.','') and City = @City 
				--and [State] = @State and Zipcode = @ZipCode
				[dbo].udf_DoesPropertyExist (
						@AddressLine1,
						@City,
						@State,
						@ZipCode
						)

		if (@PropertyID iS NOT NULL AND @OverrideDuplicate = 0)
		BEGIN
			DECLARE @ErrorString VARCHAR(3000);
			SET @ErrorString = 'Property Address ' + @AddressLine1 + ', ' + @City + ', ' + @State + ', ' + @ZipCode
			                   + ' '  + ' appears to be a duplicate of: ' + cast(@PropertyID as varchar(30));
			RAISERROR (@ErrorString, 11, -1);
--			RAISERROR('@PropertyID exists: @AddressLine1, @City, @State, @ZipCode', 11, -1);
			RETURN;
		END
		 INSERT into property (ConstructionTypeID, AreaID, isinHistoricDistrict, isRemodeled, RemodelDate, 
							  isinCityLimits, AddressLine1, ApartmentNumber, City, [State], Zipcode,
							  YearBuilt, OwnerID, isOwnerOccuppied, ReplacedPipesFaucets, TotalRemediationCosts,
							  isResidential, isCurrentlyBeingRemodeled, hasPeelingChippingPaint, County, isRental) 
					 Values ( @ConstructionTypeID, @AreaID, @isinHistoricDistrict, @isRemodeled, @RemodelDate, 
							  @isinCityLimits, @AddressLine1, @ApartmentNumber, @City, @State, @Zipcode,
							  @YearBuilt, @OwnerID, @isOwnerOccuppied, @ReplacedPipesFaucets, @TotalRemediationCosts,
							  @isResidential, @isCurrentlyBeingRemodeled, @hasPeelingChippingPaint, @County, @isRental);
		SET @PropertyID = SCOPE_IDENTITY();

		IF (@New_PropertyNotes IS NOT NULL)
			EXEC	[dbo].[usp_InsertPropertyNotes]
								@Property_ID = @PropertyID,
								@Notes = @New_PropertyNotes,
								@InsertedNotesID = @NotesID OUTPUT
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH;
END
GO
PRINT N'Altering [dbo].[usp_InsertPerson]...';


GO


-- =============================================
-- Author:		William Thier
-- Create date: 20130506
-- Description:	Stored Procedure to insert new people records
-- =============================================
-- DROP PROCEDURE usp_InsertPerson
ALTER PROCEDURE [dbo].[usp_InsertPerson]   -- usp_InsertPerson "Bonifacic",'James','Marco','19750205','M'
	-- Add the parameters for the stored procedure here
	@FirstName varchar(50) = NULL,
	@MiddleName varchar(50) = NULL,
	@LastName varchar(50) = NULL, 
	@BirthDate date = NULL,
	@Gender char(1) = NULL,
	@StatusID smallint = NULL,
	@ForeignTravel bit = NULL,
	@OutofSite bit = NULL,
	@EatsForeignFood bit = NULL,
	@PatientID smallint = NULL,
	@RetestDate datetime = NULL,
	@Moved bit = NULL,
	@MovedDate date = NULL,
	@isClosed bit = 0,
	@isResolved bit = 0,
	@New_Notes varchar(3000) = NULL,
	@GuardianID int = NULL,
	@isSmoker bit = NULL,
	@OverrideDuplicate bit = 0,
	@PID int OUTPUT 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrorLogID int, @NotesID int;

	-- set default retest date if none specified
	IF @RetestDate is null
		SET @RetestDate = DATEADD(yy,1,GetDate());
	
	Select @PID = PersonID from Person where Lastname = @LastName and FirstName = @FirstName AND BirthDate = @BirthDate;
	IF (@PID IS NOT NULL AND @OverrideDuplicate = 0)
	BEGIN
		DECLARE @ErrorString VARCHAR(3000);
		SET @ErrorString ='Person appears to be a duplicate of personID: ' + cast(@PID as varchar(256))
		RAISERROR (@ErrorString, 11, -1);
		RETURN;
	END	

    -- Insert statements for procedure here
	BEGIN TRY
		 INSERT into person ( LastName,  FirstName,  MiddleName,  BirthDate,  Gender,  StatusID, 
							  ForeignTravel,  OutofSite,  EatsForeignFood,  PatientID,  RetestDate, 
							  Moved,  MovedDate,  isClosed,  isResolved,  GuardianID,  isSmoker) 
					 Values (@LastName, @FirstName, @MiddleName, @BirthDate, @Gender, @StatusID,
							 @ForeignTravel, @OutofSite, @EatsForeignFood, @PatientID, @RetestDate,
							 @Moved, @MovedDate, @isClosed, @isResolved,  @GuardianID, @isSmoker);
		SET @PID = SCOPE_IDENTITY();

		IF (@New_Notes IS NOT NULL)
			EXEC	[dbo].[usp_InsertPersonNotes]
								@Person_ID = @PID,
								@Notes = @New_Notes,
								@InsertedNotesID = @NotesID OUTPUT
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH;
END
GO
PRINT N'Altering [dbo].[usp_SlChildStatus]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20150215
-- Description:	returns valid status codes for passed in type - Child
-- =============================================
ALTER PROCEDURE [dbo].[usp_SlChildStatus] 
	-- Add the parameters for the stored procedure here
	@TargetType varchar(50) = NULL, 
	@DEBUG BIT  = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @spexecutesqlStr NVARCHAR(3000)

	select @spexecutesqlStr =''


    -- Insert statements for procedure here
	SELECT [TS].[StatusName],[TS].[StatusID] from [TargetStatus] AS [TS]
	where 1 = 1 AND TargetType in ('Person','All')

END
GO
PRINT N'Altering [dbo].[usp_SlTargetSampleType]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20150102
-- Description:	retrieve sample types for people (lead levels)
-- =============================================
ALTER PROCEDURE [dbo].[usp_SlTargetSampleType] 
	-- Add the parameters for the stored procedure here
	@Sample_Target varchar(50) = NULL, 
	@p2 int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @spexecutesqlStr nvarchar(4000), @RECOMPILE bit =1;
    -- Insert statements for procedure here

	SELECT @spexecutesqlStr = 'SELECT [SampleTypeID],[SampleTypeName] from [SampleType] where 1=1'
	
	if (@Sample_Target IS NOT NULL)
		SELECT @spexecutesqlStr = @spexecutesqlStr + ' AND [SampleType].[SampleTarget] = @SampleTarget'

	IF @Recompile = 1
		SELECT @spexecutesqlStr = @spexecutesqlStr + ' OPTION(RECOMPILE)';

	EXEC [sp_executesql] @spexecutesqlStr
		, N'@SampleTarget varchar(50)', @SampleTarget = @Sample_Target
END
GO
PRINT N'Creating [dbo].[usp_InsertPersontoPerson]...';


GO



-- =============================================
-- Author:		William Thier
-- Create date: 20150323
-- Description:	Stored Procedure to insert 
--              new PersontoPerson records how 
--              they are related
-- =============================================

CREATE PROCEDURE [dbo].[usp_InsertPersontoPerson]   -- usp_InsertPersontoPerson
	-- Add the parameters for the stored procedure here
	@Person1ID int = NULL,
	@Person2ID smallint = NULL,
	@RelationshipType int = NULL,
	@isGuardian bit = NULL,
	@isPrimaryContact bit = NULL
	--@EndDate date = NULL,
	--@GroupID varchar(20) = NULL

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrorLogID int;
    -- Insert statements for procedure here
	BEGIN TRY
		 INSERT into PersontoPerson( Person1ID, Person2ID, RelationshipTypeID, isGuardian, isPrimaryContact ) 
					 Values ( @Person1ID, @Person2ID, @RelationShipType, @isGuardian, @isPrimaryContact )
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH;
END
GO
PRINT N'Creating [dbo].[usp_InsertTravelNotes]...';


GO


-- =============================================
-- Author:		Liam Thier
-- Create date: 20150319
-- Description:	stored procedure to insert Travel notes
-- =============================================
CREATE PROCEDURE [dbo].[usp_InsertTravelNotes] 
	-- Add the parameters for the stored procedure here
	@Family_ID int = NULL, 
	@Travel_Notes VARCHAR(3000) = NULL,
	@Start_Date date = NULL,
	@End_Date date = NULL,
	@InsertedNotesID INT OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @ErrorLogID int

    -- Insert statements for procedure here
	BEGIN TRY -- update Property information
		INSERT INTO TravelNotes (FamilyID, Notes, StartDate, EndDate) 
				values (@Family_ID, @Travel_Notes, @Start_Date, @End_Date);
		SET @InsertedNotesID = SCOPE_IDENTITY();
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		-- inserting information in the ErrorLog.
		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH; 
END
GO
PRINT N'Creating [dbo].[usp_SlDaycare]...';


GO

-- =============================================
-- Author:		Liam Thier
-- Create date: 20150319
-- Description:	returns daycare name, id, description
-- =============================================
CREATE PROCEDURE [dbo].[usp_SlDaycare] 
	-- Add the parameters for the stored procedure here
	@DEBUG BIT  = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	select DaycareID,DaycareName,DaycareDescription from Daycare

END
GO
PRINT N'Creating [dbo].[usp_SLListNursingMothers]...';


GO


-- =============================================
-- Author:		Liam Thier
-- Create date: 20150315
-- Description:	stored procedure to list nursing
--				mothers. 
--				If @Count is set to 1, returns the
--				number of nusring mothers
-- =============================================
CREATE PROCEDURE [dbo].[usp_SLListNursingMothers]
	-- Add the parameters for the stored procedure here
	  @PersonID int = NULL
	, @Count BIT = 0 -- If 1 return county only, if 0 return full list
	, @DEBUG BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @spexecuteSQLStr NVARCHAR(4000)
			, @Recompile  BIT = 1, @ErrorLogID int;
	
	BEGIN TRY
		SELECT @spexecuteSQLStr =
			N'SELECT [PersonID],[QuestionnaireID],[LastName],[FirstName],[Age],[isNursing],[QuestionnaireDate] 
			from vNursingMothers where 1=1';

		IF (@PersonID IS NOT NULL) 
			SELECT @spexecuteSQLStr = @spexecuteSQLStr
				+ N' AND [PersonID] = @PersonID';

		SELECT @spexecuteSQLStr = @spexecuteSQLStr
			+ N' order by [PersonID], [lastname]';

		-- select how many nursing mothers there are
		IF (@Count = 1)
		BEGIN
			SELECT @spexecuteSQLStr = N'SELECT count([PersonID]) from vNursingMothers';
			SET @Recompile = 0;
		END

		IF (@PersonID IS NULL) 
			SET @Recompile = 0;
	
		-- Recompile the stored procedure if the query return list is sufficiently small
		IF @Recompile = 1
			SELECT @spexecuteSQLStr = @spexecuteSQLStr + N' OPTION(RECOMPILE)';

		-- If debugging, output the query string
		IF @DEBUG = 1
			SELECT @spexecuteSQLStr, @PersonID

		EXEC [sp_executesql] @spexecuteSQLStr
			, N'@Person_ID int'
			, @Person_ID = @PersonID;
	END TRY
			BEGIN CATCH
			-- Call procedure to print error information.
			EXECUTE dbo.uspPrintError;

			-- Roll back any active or uncommittable transactions before
			-- inserting information in the ErrorLog.
			IF XACT_STATE() <> 0
			BEGIN
				ROLLBACK TRANSACTION;
			END

			EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
			RETURN ERROR_NUMBER()
		END CATCH;
END
GO
PRINT N'Creating [dbo].[usp_SlRelationShipTypes]...';


GO


-- =============================================
-- Author:		Liam Thier
-- Create date: 20150110
-- Description:	User defined stored procedure to
--              select all relationship types and IDs
-- =============================================
CREATE PROCEDURE [dbo].[usp_SlRelationShipTypes]
	-- Add the parameters for the stored procedure her
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @spexecutesqlStr	NVARCHAR (4000),
        @Recompile  BIT = 1, @ErrorLogID int;

    -- Insert statements for procedure here
	select @spexecutesqlStr ='SELECT [RT].[RelationshipTypeID], [RT].[RelationshipTypeName]
	from [RelationshipType] AS [RT]
	where 1 = 1'
	
	-- Return all families and associated properties if nothing was passed in
	SET @Recompile = 0

	-- order by last name
	SELECT @spexecutesqlStr = @spexecutesqlStr + N' order by [RT].[RelationshipTypeName]'
		
	IF @Recompile = 1
		SELECT @spexecutesqlStr = @spexecutesqlStr + N' OPTION(RECOMPILE)';

	BEGIN TRY 
		EXEC [sp_executesql] @spexecutesqlStr;
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Add error information to errorlog
		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER()
	END CATCH;
END
GO
PRINT N'Creating [dbo].[usp_SlStatus]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20150215
-- Description:	returns valid status codes for passed in type - Child
-- =============================================
CREATE PROCEDURE [dbo].[usp_SlStatus] 
	-- Add the parameters for the stored procedure here
	@TargetType varchar(50) = NULL, 
	@DEBUG BIT  = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	-- IF (@StatusType = 'Child')
		select statusName from TargetStatus where TargetType = @TargetType

END
GO
PRINT N'Altering [dbo].[usp_InsertFamily]...';


GO

-- =============================================
-- Author:		William Thier
-- Create date: 20140205
-- Description:	Stored Procedure to insert new Family information
-- =============================================

ALTER PROCEDURE [dbo].[usp_InsertFamily]  
	-- Add the parameters for the stored procedure here
	@LastName varchar(50) = NULL,
	@NumberofSmokers tinyint = 0,
	@PrimaryLanguageID tinyint = 1,
	@Notes varchar(3000) = NULL,
	@New_Travel_Notes varchar(3000) = NULL,
	@Travel_Start_Date date = NULL,
	@Travel_End_Date date = NULL,
	@Pets tinyint = NULL,
	@inandout bit = NULL,
	@PrimaryPropertyID int = NULL,
	@FrequentlyWashPets bit = NULL,
	@FID int OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	DECLARE @ErrorLogID int, @FamilyNotesReturnValue int, @InsertedFamilyNotesID int
			, @TravelNotesReturnValue int, @InsertedTravelNotesID int;

	BEGIN TRY -- insert Family
		BEGIN TRANSACTION InsertFamilyTransaction
			INSERT into Family ( LastName,  NumberofSmokers,  PrimaryLanguageID, Pets, inandout
						, PrimaryPropertyID) 
						Values (@LastName, @NumberofSmokers, @PrimaryLanguageID, @Pets, @inandout
						, @PrimaryPropertyID)
			SET @FID = SCOPE_IDENTITY();  -- uncomment to return primary key of inserted values

			IF (@Notes IS NOT NULL)
				EXEC	@FamilyNotesReturnValue = [dbo].[usp_InsertFamilyNotes]
													@Family_ID = @FID,
													@Notes = @Notes,
													@InsertedNotesID = @InsertedFamilyNotesID OUTPUT
	
			IF (@New_Travel_Notes IS NOT NULL)
				EXEC	@TravelNotesReturnValue = [dbo].[usp_InsertTravelNotes]
						@Family_ID = @FID,
						@Travel_Notes = @New_Travel_Notes,
						@Start_Date = @Travel_Start_Date,
						@End_Date = @Travel_End_Date,
						@InsertedNotesID = @InsertedTravelNotesID OUTPUT

		COMMIT TRANSACTION InsertFamilyTransaction
	END TRY
	BEGIN CATCH
		-- Call procedure to print error information.
		EXECUTE dbo.uspPrintError;

		-- Roll back any active or uncommittable transactions before
		-- inserting information in the ErrorLog.
		IF XACT_STATE() <> 0
		BEGIN
			ROLLBACK TRANSACTION;
		END

		EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
		RETURN ERROR_NUMBER();
	END CATCH; 
END
GO
PRINT N'Altering [dbo].[usp_InsertNewClientWebScreen]...';


GO
-- =============================================
-- Author:		Liam Thier
-- Create date: 20141115
-- Description:	stored procedure to insert data from the Add a new client web page
-- =============================================
ALTER PROCEDURE [dbo].[usp_InsertNewClientWebScreen]
	-- Add the parameters for the stored procedure here
	@Family_ID int = NULL, 
	@First_Name varchar(50) = NULL,
	@Middle_Name varchar(50) = NULL,
	@Last_Name varchar(50) = NULL,
	@Birth_Date date = NULL,
	@Gender_ char(1) = NULL,
	@Language_ID tinyint = NULL,
	-- @Child_ID varchar(50) = 'Leadville',
	@Ethnicity_ID varchar(2) = NULL, -- store as binary/bitmap
	@Moved_ bit = NULL,
	@Travel bit = NULL, --ForeignTravel
	@Travel_Notes varchar(3000) = NULL,
	@Out_of_Site bit = NULL, 
	@Hobby_ID smallint = NULL,
	@Hobby_Notes varchar(3000) = NULL,
	@Child_Notes varchar(3000) = NULL,
	@Release_Notes varchar(3000) = NULL,
	@is_Smoker bit = NULL,
	@Occupation_ID smallint = NULL,
	@Occupation_Start_Date date = NULL,
	@OverrideDuplicatePerson bit = 0,
	@ClientID int OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN
		DECLARE @ErrorLogID int,
				@PersontoFamily_return_value int,
				@PersontoLanguage_return_value int,
				@PersontoHobby_return_value int,
				@PersontoOccupation_return_value int,
				@PersontoEthnicity_return_value int;
	
		-- If no family ID was passed in exit
		IF (@Family_ID IS NULL)
		BEGIN
			RAISERROR ('Family name must be supplied', 11, -1);
			RETURN;
		END;

		-- If the family doesn't exist, return an error
		IF ((select FamilyID from family where FamilyID = @Family_ID) is NULL)
		BEGIN
			DECLARE @ErrorString VARCHAR(3000);
			SET @ErrorString = 'Unable to associate non-existent family. Family does not exist.'
			RAISERROR (@ErrorString, 11, -1);
			RETURN;
		END
	
		if (@Last_Name is null)
		BEGIN
			select @Last_Name = Lastname from Family where FamilyID = @Family_ID
		END

		BEGIN TRY  -- insert new person
			EXEC	[dbo].[usp_InsertPerson]
					@FirstName = @First_Name,
					@MiddleName = @Middle_Name,
					@LastName = @Last_Name,
					@BirthDate = @Birth_Date,
					@Gender = @Gender_,
					-- @Ethnicity,
					@Moved = @Moved_,
					@ForeignTravel = @Travel,
					-- @TravelNotes,
					@OutofSite = @Out_of_Site,
					-- @HobbyNotes,
					@New_Notes = @Child_Notes,
					@isSmoker = @is_Smoker,
					@OverrideDuplicate = @OverrideDuplicatePerson,
					@PID = @CLientID OUTPUT;

			-- Associate person to family
			if (@Family_ID is not NULL)
			EXEC	@PersontoFamily_return_value = usp_InsertPersontoFamily
					@PersonID = @ClientID, @FamilyID = @Family_ID, @OUTPUT = @PersontoFamily_return_value OUTPUT;

			-- Associate person to language
			if (@Language_ID is not NULL)
			EXEC 	@PersontoLanguage_return_value = usp_InsertPersontoLanguage
					@LanguageID = @Language_ID, @PersonID = @ClientID, @isPrimaryLanguage = 1;

			-- associate person to Hobby
			if (@Hobby_ID is not NULL)
			EXEC	@PersontoHobby_return_value = usp_InsertPersontoHobby
					@HobbyID = @Hobby_ID, @PersonID = @ClientID;

			-- associate person to occupation
			if (@Occupation_ID is not NULL)
			EXEC	@PersontoOccupation_return_value = [dbo].[usp_InsertPersontoOccupation]
					@PersonID = @ClientID,
					@OccupationID = @Occupation_ID
		END TRY
		BEGIN CATCH -- insert person
			-- Call procedure to print error information.
			EXECUTE dbo.uspPrintError;

			-- Roll back any active or uncommittable transactions before
			-- inserting information in the ErrorLog.
			IF XACT_STATE() <> 0
			BEGIN
				ROLLBACK TRANSACTION;
			END

			EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
			RETURN ERROR_NUMBER()
		END CATCH; -- insert new person
	END

	IF (@Family_ID is not NULL AND @PersontoFamily_return_value <> 0) 
	BEGIN
		RAISERROR ('Error associating person to family', 11, -1);
		RETURN;
	END
	
	IF (@Hobby_ID is not NULL AND @PersontoHobby_return_value <> 0)
	BEGIN
		RAISERROR ('Error associating person to Hobby', 11, -1);
		RETURN;
	END
	
	IF (@Language_ID is not NULL AND @PersontoLanguage_return_value <> 0) 
	BEGIN
		RAISERROR ('Error associating person to language', 11, -1);
		RETURN;
	END
	
	IF (@Occupation_ID is not NULL and @PersontoOccupation_return_value <> 0)
	BEGIN
		RAISERROR ('Error associating person to occupation', 11, -1);
		RETURN;
	END
END
GO
PRINT N'Altering [dbo].[usp_InsertNewFamilyWebScreen]...';


GO


-- =============================================
-- Author:		Liam Thier
-- Create date: 20141115
-- Description:	stored procedure to insert data from the Add a new family web page
-- =============================================
-- 20150102	Fixed bug with family/property association checking
ALTER PROCEDURE [dbo].[usp_InsertNewFamilyWebScreen]
	-- Add the parameters for the stored procedure here
	@FamilyLastName varchar(50) = NULL, 
	@Address_Line1 varchar(100) = NULL,
	@ApartmentNum varchar(10) = NULL,
	@CityName varchar(50) = NULL,
	@StateAbbr char(2) = NULL,
	@ZipCode varchar(10) = NULL,
	@Year_Built date = NULL,
	@Owner_id int = NULL,
	@is_Owner_Occupied bit = NULL,
	@is_Residential bit = NULL,
	@has_Peeling_Chipping_Paint bit = NULL,
	@is_Rental bit = NULL,
	@HomePhone bigint = NULL,
	@WorkPhone bigint = NULL,
	@Language tinyint = NULL, 
	@NumSmokers tinyint = NULL,
	@Pets tinyint = NULL,
	@Frequently_Wash_Pets bit = NULL,
	@Petsinandout bit = NULL,
	@FamilyNotes varchar(3000) = NULL,
	@PropertyNotes varchar(3000) = NULL,
	@Travel_Notes varchar(3000) = NULL,
	@Travel_Start_Date varchar(3000) = NULL,
	@Travel_End_Date varchar(3000) = NULL,
	@OverrideDuplicateProperty bit = 0,
	@OverrideDuplicateFamilyPropertyAssociation bit = 0,
	@DEBUG BIT = 0,
	@FamilyID int OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (@FamilyLastName IS NULL
		AND @Address_Line1 IS NULL
		AND @ApartmentNum IS NULL
		AND @HomePhone IS NULL
		AND @WorkPhone IS NULL)
	BEGIN
		RAISERROR ('You must supply at least one of the following: Family name, StreetNumber, Street Name, Street Suffix, Apartment number, Home phone, or Work phone', 11, -1);
		RETURN;
	END;

	BEGIN
		DECLARE @return_value int,
				@PhoneTypeID tinyint, 
				@Family_return_value int,
				@PropID int, @LID tinyint,
				@PhoneNumberID_OUTPUT int,
				@Homephone_return_value int,
				@Workphone_return_value int,
				@NewFamilyNotesID int,
				@TravelNotesReturnValue int,
				@ErrorLogID int;

		BEGIN TRY
			-- Insert the property address if it doesn't already exist
			-- NEED TO RETRIEVE PROPERTY ID IF IT ALREADY EXISTS
			SELECT @PropID = PropertyID from Property where
					replace(AddressLine1,'.','') = replace(@Address_Line1,'.','') and City = @CityName 
					and [State] = @StateAbbr and Zipcode = @ZipCode

			--if (@is_Owner_Occupied = 1) 
			--	select @Owner_id = IDENT_CURRENT('Family')+1

			if ( @PropID is NULL)
			BEGIN -- enter property
				EXEC	[dbo].[usp_InsertProperty] 
						@AddressLine1 = @Address_Line1,
						@City = @CityName,
						@State = @StateAbbr,
						@Zipcode = @ZipCode,
						@New_PropertyNotes = @PropertyNotes,
						@YearBuilt = @Year_Built,
						@Ownerid = @Owner_id,
						@isOwnerOccuppied = @is_Owner_Occupied,
						@isResidential = @is_Residential,
						@hasPeelingChippingPaint = @has_Peeling_Chipping_Paint,
						@isRental = @is_Rental,
						@OverrideDuplicate = @OverrideDuplicateProperty,
						@PropertyID = @PropID OUTPUT;
					END -- enter property
			-- Check if Family is already associated with property, if so, skip insert and return warning:
			if ((select count(PrimarypropertyID) from Family where LastName = @FamilyLastName and PrimaryPropertyID = @PropID) > 0)
			BEGIN
				if ( @OverrideDuplicateFamilyPropertyAssociation = 1)
				BEGIN
					-- update address in the future??
					RAISERROR ('Family is already associated with that Property', 11, -1);
					RETURN;
				END
-- 				SET @return_value =  
			END
			ELSE
			BEGIN
				EXEC	[dbo].[usp_InsertFamily]
						@LastName = @FamilyLastName,
						@NumberofSmokers = @NumSmokers,
						@PrimaryLanguageID = @Language,
						@Pets = @Pets,
						@FrequentlyWashPets = @Frequently_Wash_Pets,
						@inandout = @Petsinandout,
						@PrimaryPropertyID = @PropID,
						@Notes = @FamilyNotes,
						@New_Travel_Notes = @Travel_Notes,
						@Travel_Start_Date = @Travel_Start_Date,
						@Travel_End_Date = @Travel_End_Date,
						@FID = @FamilyID OUTPUT;
			END

			if (@HomePhone is not NULL) 
			BEGIN  -- insert Home Phone
				SELECT @PhoneTypeID = PhoneNumberTypeID from PhoneNumberType where PhoneNumberTypeName = 'Home Phone';
				
				EXEC	@Homephone_return_value = [dbo].[usp_InsertPhoneNumber]
						@PhoneNumber = @HomePhone,
						@PhoneNumberTypeID = @PhoneTypeID,
						@PhoneNumberID_OUTPUT = @PhoneNumberID_OUTPUT OUTPUT
			END  -- insert Home Phone

			if (@WorkPhone is not NULL) 
			BEGIN  -- insert Work Phone
				SELECT @PhoneTypeID = PhoneNumberTypeID from PhoneNumberType where PhoneNumberTypeName = 'Work Phone';

				EXEC	@Workphone_return_value = [dbo].[usp_InsertPhoneNumber]
						@PhoneNumber = @HomePhone,
						@PhoneNumberTypeID = @PhoneTypeID,
						@PhoneNumberID_OUTPUT = @PhoneNumberID_OUTPUT OUTPUT
			END  -- insert Work Phone
		END TRY
		BEGIN CATCH
			-- Call procedure to print error information.
			EXECUTE dbo.uspPrintError;

			-- Roll back any active or uncommittable transactions before
			-- inserting information in the ErrorLog.
			IF XACT_STATE() <> 0
			BEGIN
				ROLLBACK TRANSACTION;
			END

			EXECUTE dbo.uspLogError @ErrorLogID = @ErrorLogID OUTPUT;
			RETURN ERROR_NUMBER()
		END CATCH; 
	END
END
GO
PRINT N'Creating [dbo].[TravelNotes].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Collection of family and travel notes', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TravelNotes';


GO
PRINT N'Creating [dbo].[TravelNotes].[CreatedDate].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'date the notes where added', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'TravelNotes', @level2type = N'COLUMN', @level2name = N'CreatedDate';


GO
PRINT N'Creating [dbo].[vNursingMothers].[MS_DiagramPane1]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPane1', @value = N'[0E232FF0-B466-11cf-A24F-00AA00A3EFFF, 1.00]
Begin DesignProperties = 
   Begin PaneConfigurations = 
      Begin PaneConfiguration = 0
         NumPanes = 4
         Configuration = "(H (1[40] 4[20] 2[20] 3) )"
      End
      Begin PaneConfiguration = 1
         NumPanes = 3
         Configuration = "(H (1 [50] 4 [25] 3))"
      End
      Begin PaneConfiguration = 2
         NumPanes = 3
         Configuration = "(H (1 [50] 2 [25] 3))"
      End
      Begin PaneConfiguration = 3
         NumPanes = 3
         Configuration = "(H (4 [30] 2 [40] 3))"
      End
      Begin PaneConfiguration = 4
         NumPanes = 2
         Configuration = "(H (1 [56] 3))"
      End
      Begin PaneConfiguration = 5
         NumPanes = 2
         Configuration = "(H (2 [66] 3))"
      End
      Begin PaneConfiguration = 6
         NumPanes = 2
         Configuration = "(H (4 [50] 3))"
      End
      Begin PaneConfiguration = 7
         NumPanes = 1
         Configuration = "(V (3))"
      End
      Begin PaneConfiguration = 8
         NumPanes = 3
         Configuration = "(H (1[56] 4[18] 2) )"
      End
      Begin PaneConfiguration = 9
         NumPanes = 2
         Configuration = "(H (1 [75] 4))"
      End
      Begin PaneConfiguration = 10
         NumPanes = 2
         Configuration = "(H (1[66] 2) )"
      End
      Begin PaneConfiguration = 11
         NumPanes = 2
         Configuration = "(H (4 [60] 2))"
      End
      Begin PaneConfiguration = 12
         NumPanes = 1
         Configuration = "(H (1) )"
      End
      Begin PaneConfiguration = 13
         NumPanes = 1
         Configuration = "(V (4))"
      End
      Begin PaneConfiguration = 14
         NumPanes = 1
         Configuration = "(V (2))"
      End
      ActivePaneConfig = 0
   End
   Begin DiagramPane = 
      Begin Origin = 
         Top = 0
         Left = 0
      End
      Begin Tables = 
         Begin Table = "u"
            Begin Extent = 
               Top = 6
               Left = 38
               Bottom = 136
               Right = 255
            End
            DisplayFlags = 280
            TopColumn = 0
         End
         Begin Table = "q"
            Begin Extent = 
               Top = 6
               Left = 293
               Bottom = 119
               Right = 467
            End
            DisplayFlags = 280
            TopColumn = 0
         End
      End
   End
   Begin SQLPane = 
   End
   Begin DataPane = 
      Begin ParameterDefaults = ""
      End
   End
   Begin CriteriaPane = 
      Begin ColumnWidths = 11
         Column = 1440
         Alias = 900
         Table = 1170
         Output = 1035
         Append = 1400
         NewValue = 1170
         SortType = 1350
         SortOrder = 1410
         GroupBy = 1350
         Filter = 1350
         Or = 1350
         Or = 1350
         Or = 1350
      End
   End
End
', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'vNursingMothers';


GO
PRINT N'Creating [dbo].[vNursingMothers].[MS_DiagramPaneCount]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_DiagramPaneCount', @value = 1, @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'VIEW', @level1name = N'vNursingMothers';


GO
PRINT N'Creating [dbo].[BloodTestResults].[HistoricLabResultsID].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'historic lab results id from access database', @level0type = N'SCHEMA', @level0name = N'dbo', @level1type = N'TABLE', @level1name = N'BloodTestResults', @level2type = N'COLUMN', @level2name = N'HistoricLabResultsID';


GO
PRINT N'Refreshing [dbo].[usp_InsertBloodTestResults]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_InsertBloodTestResults]';


GO
PRINT N'Refreshing [dbo].[usp_SLAllBloodTestResultsMetaData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_SLAllBloodTestResultsMetaData]';


GO
PRINT N'Refreshing [dbo].[usp_SLInsertedDataMetaData]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_SLInsertedDataMetaData]';


GO
PRINT N'Refreshing [dbo].[usp_InsertHistoricFamily]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_InsertHistoricFamily]';


GO
PRINT N'Refreshing [dbo].[usp_SLInsertedDataSimplified]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_SLInsertedDataSimplified]';


GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[TravelNotes] WITH CHECK CHECK CONSTRAINT [FK_TravelNotes_Family];


GO
PRINT N'Update complete.';


GO
